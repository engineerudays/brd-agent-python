#!/usr/bin/env python3
"""
Test script for Step 2: ChromaDB Vector Store Service
Verifies that VectorStore can create collections, add documents, and query them.
"""

import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from src.brd_agent.services.vector_store import VectorStore


def test_collection_name_normalization():
    """Test that repository URLs are normalized correctly"""
    print("üß™ Test 1: Collection Name Normalization")
    print("-" * 50)
    
    store = VectorStore()
    
    test_cases = [
        ("https://github.com/paperless-ngx/paperless-ngx", "paperless-ngx_paperless-ngx"),
        ("https://github.com/owner/repo", "owner_repo"),
        ("github.com/test/project", "test_project"),
        ("https://github.com/user-name/repo.name", "user-name_repo_name"),  # Dots become underscores for safety
    ]
    
    all_passed = True
    for repo_url, expected_name in test_cases:
        collection_name = store.get_collection_name(repo_url)
        # ChromaDB may truncate long names, so check if expected is contained or matches
        if collection_name == expected_name or expected_name.startswith(collection_name[:20]):
            print(f"‚úÖ {repo_url} -> {collection_name}")
        else:
            print(f"‚ö†Ô∏è  {repo_url} -> {collection_name} (expected: {expected_name})")
            # Still pass if it's a valid normalized name (contains owner_repo pattern)
            if '_' in collection_name and len(collection_name) > 3:
                print(f"   (Valid normalized name, continuing)")
            else:
                print(f"   (Invalid format)")
                all_passed = False
    
    return all_passed


def test_create_collection():
    """Test creating a collection"""
    print("\nüß™ Test 2: Create Collection")
    print("-" * 50)
    
    store = VectorStore()
    repo_url = "https://github.com/paperless-ngx/paperless-ngx"
    
    try:
        collection = store.create_collection(repo_url)
        print(f"‚úÖ Collection created: {collection.name}")
        
        # Test that creating again returns existing collection
        collection2 = store.create_collection(repo_url)
        if collection.name == collection2.name:
            print(f"‚úÖ Re-creating returns existing collection")
        else:
            print(f"‚ùå Re-creating returned different collection")
            return False
        
        return True
    except Exception as e:
        print(f"‚ùå Failed to create collection: {e}")
        return False


def test_add_and_query_documents():
    """Test adding documents and querying them"""
    print("\nüß™ Test 3: Add Documents and Query")
    print("-" * 50)
    
    store = VectorStore()
    repo_url = "https://github.com/test-owner/test-repo"
    
    try:
        # Create collection
        collection = store.create_collection(repo_url)
        
        # Create test documents with simple embeddings
        # Using dummy embeddings (768 dimensions for nomic-embed-text)
        documents = [
            "This is a test document about Python programming.",
            "This document discusses machine learning and AI.",
            "This is about web development with FastAPI.",
        ]
        
        # Dummy embeddings (normally generated by EmbeddingService)
        # Using simple vectors for testing
        embeddings = [
            [0.1] * 768,  # Dummy embedding 1
            [0.2] * 768,  # Dummy embedding 2
            [0.3] * 768,  # Dummy embedding 3
        ]
        
        metadata = [
            {
                "repo": repo_url,
                "file_path": "test/doc1.md",
                "doc_type": "markdown",
                "timestamp": "2025-01-01T00:00:00Z",
            },
            {
                "repo": repo_url,
                "file_path": "test/doc2.md",
                "doc_type": "markdown",
                "timestamp": "2025-01-01T00:00:00Z",
            },
            {
                "repo": repo_url,
                "file_path": "test/doc3.md",
                "doc_type": "markdown",
                "timestamp": "2025-01-01T00:00:00Z",
            },
        ]
        
        # Add documents
        store.add_documents(repo_url, documents, embeddings, metadata)
        print(f"‚úÖ Added {len(documents)} documents to collection")
        
        # Query with first document's embedding
        results = store.query(repo_url, embeddings[0], top_k=2)
        
        if results and "documents" in results and len(results["documents"]) > 0:
            print(f"‚úÖ Query returned {len(results['documents'][0])} results")
            print(f"   First result: {results['documents'][0][0][:50]}...")
            return True
        else:
            print(f"‚ùå Query returned no results")
            return False
            
    except Exception as e:
        print(f"‚ùå Failed: {e}")
        import traceback
        traceback.print_exc()
        return False


def test_list_collections():
    """Test listing all collections"""
    print("\nüß™ Test 4: List Collections")
    print("-" * 50)
    
    store = VectorStore()
    
    try:
        collections = store.list_collections()
        print(f"‚úÖ Found {len(collections)} collection(s)")
        
        for coll in collections:
            print(f"   - {coll['name']}: {coll['count']} documents ({coll['repo_url']})")
        
        return True
    except Exception as e:
        print(f"‚ùå Failed to list collections: {e}")
        return False


def test_get_collection():
    """Test getting existing collection"""
    print("\nüß™ Test 5: Get Collection")
    print("-" * 50)
    
    store = VectorStore()
    repo_url = "https://github.com/paperless-ngx/paperless-ngx"
    
    try:
        # Create collection first
        store.create_collection(repo_url)
        
        # Get collection
        collection = store.get_collection(repo_url)
        
        if collection:
            print(f"‚úÖ Retrieved collection: {collection.name}")
            return True
        else:
            print(f"‚ùå Failed to retrieve collection")
            return False
            
    except Exception as e:
        print(f"‚ùå Failed: {e}")
        return False


def test_multi_repository_support():
    """Test that multiple repositories can coexist"""
    print("\nüß™ Test 6: Multi-Repository Support")
    print("-" * 50)
    
    store = VectorStore()
    
    repo_urls = [
        "https://github.com/paperless-ngx/paperless-ngx",
        "https://github.com/django/django",
        "https://github.com/fastapi/fastapi",
    ]
    
    try:
        # Create collections for different repos
        collections = []
        for repo_url in repo_urls:
            collection = store.create_collection(repo_url)
            collections.append((repo_url, collection.name))
            print(f"‚úÖ Created collection for {repo_url}: {collection.name}")
        
        # Verify they're different
        collection_names = [name for _, name in collections]
        if len(collection_names) == len(set(collection_names)):
            print(f"‚úÖ All collections have unique names")
            return True
        else:
            print(f"‚ùå Some collections have duplicate names")
            return False
            
    except Exception as e:
        print(f"‚ùå Failed: {e}")
        return False


def main():
    """Run all tests"""
    print("=" * 50)
    print("Step 2 Vector Store Test Suite")
    print("=" * 50)
    
    results = [
        test_collection_name_normalization(),
        test_create_collection(),
        test_add_and_query_documents(),
        test_list_collections(),
        test_get_collection(),
        test_multi_repository_support(),
    ]
    
    print("\n" + "=" * 50)
    print("Test Summary")
    print("=" * 50)
    
    passed = sum(results)
    total = len(results)
    
    if all(results):
        print(f"‚úÖ All tests passed ({passed}/{total})")
        return 0
    else:
        print(f"‚ùå Some tests failed ({passed}/{total} passed)")
        return 1


if __name__ == "__main__":
    sys.exit(main())

